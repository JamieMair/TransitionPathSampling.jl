var documenterSearchIndex = {"docs":
[{"location":"manual/examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"These are just some examples of how to use this package.","category":"page"},{"location":"manual/guide/#Package-Guide","page":"Guide","title":"Package Guide","text":"","category":"section"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"This package is designed to help quickly implement Transition Path Sampling (TPS) on user defined problems, providing a set of useful dynamics and utilities to help speed up research.","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"Briefly, TPS is a method to sample rare trajectories. If you have some dynamics that produces a trajectory, e.g. a discrete-time random walk, but want to observe some rare behaviour, and want to sample trajectories that are atypical, TPS provides a computationally efficient way of doing this, while still providing the correct statistics. TPS can be thought of as a type of Metropolis-Hastings algorithm.","category":"page"},{"location":"manual/guide/#Getting-started","page":"Guide","title":"Getting started","text":"","category":"section"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"Let's imagine generating independent discrete-time continuous-space random walk trajectories, which form a trajectory of independent parameters. This dynamics does not produce interesting trajectories, so instead, we can bias towards some observable of the parameters. If we have a trajectory omega, sampled with some probability given by p(omega), then we can define some interesting rare-event distribution p(omega) which is biased towards an observable, mathcalO, via","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"p(omega) = fracp(omega) e^-smathcalO(omega)mathcalZ ","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"where mathcalZ is the partition sum of the new distribution, which acts to normalise p(omega). We can define the observable as the following:","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"using TransitionPathSampling\nobs_norm(state::AbstractArray) = sum(abs2, state) # Single state in the trajectory\nobs_norm(states::AbstractArray{T}) where {T<:AbstractArray} = sum(obs_norm, states) # Trajectory of states\n# Wrap the function in a SimpleObservable type\nobservable = TransitionPathSampling.SimpleObservable(obs_norm)","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"We can define the initial trajectory as all zeros, and create a problem with this initial trajectory and the observable.","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"trajectory_length = 8\nnum_parameters = 2\ntrajectory = [zeros(Float64, num_parameters) for _ in 1:trajectory_length] # Array of states\nproblem = TransitionPathSampling.DiscreteTrajectory.DTProblem(observable, trajectory)","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"Now we can choose an algorithm which provides our underlying dynamics:","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"using TransitionPathSampling.MetropolisHastings\n\ns = 1.0 # Bias parameter\nsigma = 0.1 # s.t.d of dynamics\nchance_to_shoot = 2 / trajectory_length # Probability to shoot (vs probability to bridge)\nmax_width = 1 # Only change one state at a time\nalgorithm = gaussian_trajectory_algorithm(s, sigma; chance_to_shoot, max_width)","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"This algorithm will perform shooting (i.e. running the dynamics forwards or backwards in time from a fixed point in the trajectory, regenerating part of the trajectory) with a probability of frac28, and only edit a single state on each update. We also provide a way of producing Brownian bridges between two fixed points so that states in the middle of the trajectory can be efficiently updated as well. More information on the exact dynamics can be found in this paper.","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"Now we have everything we need to run the dynamics:","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"epochs = 100 # Number of samples to make\nsolution = solve(problem, algorithm, epochs)","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"We can access the final state of the solution:","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"final_state = get_current_state(solution)","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"or, get the observations along the way:","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"observable_values = get_observations(solution)","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"This highlights the basic interface to the package, but it can be extended to use your own dynamics, which will be covered in the next section.","category":"page"},{"location":"manual/dynamics/#Dynamics","page":"Dynamics","title":"Dynamics","text":"","category":"section"},{"location":"manual/dynamics/","page":"Dynamics","title":"Dynamics","text":"Currently, this package assumes that the trajectory is discrete in time, and has a fixed number of points. In the future, this package may be extended to include continuous-time processes as well.","category":"page"},{"location":"manual/dynamics/#Random-Walk-Dynamics","page":"Dynamics","title":"Random Walk Dynamics","text":"","category":"section"},{"location":"manual/dynamics/","page":"Dynamics","title":"Dynamics","text":"A common underlying dynamics for trajectories that are discrete in time, but continuous in space, is the random walk dynamics. These are common as they have nice ergodic properties and are simple to generate samples from. One can think of these dynamics as exploring the state space.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = TransitionPathSampling","category":"page"},{"location":"#TransitionPathSampling.jl","page":"Home","title":"TransitionPathSampling.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for TransitionPathSampling. Written and maintained by Jamie Mair.","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Apply discrete-time Transition Path Sampling to functions with arbitrary observables.\nDiscrete time random walk dynamics.\nSyntax framework for extending functionality.\nSome support for detecting convergence to the steady state.\nSome support for annealing towards the steady state.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Package Guide provides a tutorial explaining how to get started using Documenter.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some examples of packages using Documenter can be found on the Examples page.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the Index for the complete list of documented functions and types.","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TODO: Fix this outline","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"manual/guide.md\", \"manual/examples.md\"]\nDepth = 1","category":"page"},{"location":"#Library-Outline","page":"Home","title":"Library Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [TransitionPathSampling]","category":"page"},{"location":"#TransitionPathSampling.get_initial_state-Tuple{TPSProblem}","page":"Home","title":"TransitionPathSampling.get_initial_state","text":"get_initial_state(problem)\n\nRetrieves an initial state for the problem specified.\n\nExamples\n\njulia> initial_state = get_initial_state(problem)\n\n\n\n\n\n","category":"method"},{"location":"#main-index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
